use Data::Dumper;
use Lookup qw(lookup);
use Regions qw(%code_country %country_continent %country_code);
use Sys::Hostname;

$VERSION = '1.05';
my $boot_time = time;

BEGIN {

     $sockaddr_t = 'S n a4 x8';

     $WEIGHT_PER_USER = 50; # should be consistent with poller
     $need_maint = 0;
     $poller_config = "dinamed.config";
     $hostmaster = "ask.develooper.com";

}

LBDB::add_static("ddns.develooper.com",T_SOA,
         rr_SOA(hostname,$hostmaster,time, 86400, 86400, 86400, 0)
);

LBDB::add_dynamic("cpan.ddns.develooper.com"  => \&handle_cpan_request);
LBDB::add_dynamic("apache.ddns.develooper.com"=> \&handle_cpan_request);
LBDB::add_dynamic("mgmt.ddns.develooper.com"  => \&handle_manage_request);

my $cpan_queries = 0;

############################################################
# dynamic domain handlers...

sub by_weight { $weight{$a} <=> $weight{$b}; }

sub handle_cpan_request {
   my($domain,$residual,$qtype,$qclass,$dm,$host_asking) = @_;

   write_log("domain: $domain / res: $residual / qt: $qtype, qc: $qclass / host_asking: $host_asking");

   my ($subdomain) = ($domain =~ m/^(.*?)\./);

   $cpan_queries++;

   #warn Data::Dumper->Dump([\$dm, \%weight], [qw(dm weight)]);

   my $qname = $residual;

   #print "qname: $qname\n";
   #print "resid: $residual\n";

   my $group;


   # could argue we should assume us as most places have better
   # connections to the us.... :-/
   my $cc = lookup($host_asking) || "xx"; 
   my $continent = $country_continent{$code_country{$cc}} || 'not-available';
   $continent =~ s/ /-/g;

   for my $group_name ("$qname.$cc.$subdomain", "$qname.$continent.$subdomain", "$qname.$subdomain") {
     #warn "trying $group_name\n";
     last if ($group = $best_groups{$group_name});
   }

   unless ($group) {
       $dm->{'rcode'} = NXDOMAIN;
       #warn "NXDOMAIN .. :-/";
       return 1;
   } 

   if ($qtype == T_A || $qtype == T_MX || $qtype == T_ANY || $qtype == T_TXT) {
     my @hosts = sort by_weight @{$group};

     #@{$group} = 

     my $the_host = $hosts[0];
     
     #$weight{$the_host} += 2 * $WEIGHT_PER_USER;
     $weight{$the_host} += 1;
     
     my $the_ip    = $ip_host{$the_host};
     $the_host .= ".develooper.com" if ($the_host !~ /\.$/);
     
     #my $answer = dns_answer(QPTR, T_CNAME, C_IN, 30, rr_CNAME($the_host));
     #$answer .= dns_answer(
     #          dns_simple_dname($the_host),
     #          T_A,C_IN,3600,
     #          rr_A($the_ip));
     
     my $ttl = 300;
     my @answers;

     
     push @answers, dns_answer(QPTR, T_A, C_IN, $ttl, rr_A($the_ip))
       if ($qtype == T_A or $qtype == T_ANY);

     push @answers, dns_answer(QPTR, T_TXT, C_IN, $ttl, rr_TXT("serviced by $the_host"))
       if ($qtype == T_TXT or $qtype == T_ANY);

     if ($qtype == T_MX or $qtype == T_ANY) {
       push @answers, dns_answer(QPTR, T_MX, C_IN, 3600*144, rr_MX(10,"miette.develooper.com"));
       push @answers, dns_answer(QPTR, T_MX, C_IN, 3600*144, rr_MX(11,"relaybackup.netcetera.dk"));
     }

     $dm->{'answer'}  .= join "", @answers;
     $dm->{'ancount'} += @answers;
   } else {
     $dm->{'rcode'} = NXDOMAIN;
   }
   return 1;
}

sub handle_manage_request {
   my($domain,$residual,$qtype,$qclass,$dm,$host_asking) = @_;

   write_log("domain: $domain / res: $residual / qt: $qtype, qc: $qclass / host_asking: $host_asking");

   #warn Data::Dumper->Dump([\$dm, \%weight], [qw(dm weight)]);

   my $qname = $residual;

   if ($qtype == T_ANY || $qtype == T_TXT || $qtype == T_MX) {
     
     my $ttl = 0;
     my @answers;

     if ($residual =~ m/^(\d+\.\d+\.\d+\.\d+)\.reload$/) {
       my $ip_to_lookup = $1;
       my $result = lookup($ip_to_lookup, 1);
       push @answers, dns_answer(QPTR, T_TXT, C_IN, 0, rr_TXT("$ip_to_lookup is " . $result ? $result : "NA" ));
     } else {
       push @answers, dns_answer(QPTR, T_TXT, C_IN, $ttl, rr_TXT("dinamed/$VERSION"));
       push @answers, dns_answer(QPTR, T_TXT, C_IN, $ttl, rr_TXT("Host: ".hostname));
       push @answers, dns_answer(QPTR, T_TXT, C_IN, $ttl, rr_TXT("Started: ". scalar localtime($boot_time)));
       push @answers, dns_answer(QPTR, T_TXT, C_IN, $ttl, rr_TXT("Now:     ". scalar localtime));
       push @answers, dns_answer(QPTR, T_TXT, C_IN, $ttl, rr_TXT("Questions: $cpan_queries"));
     }

     if ($subdomain eq "cpan" and ($qtype == T_MX or $qtype == T_ANY)) {
       push @answers, dns_answer(QPTR, T_MX, C_IN, 3600*144, rr_MX(10,"miette.develooper.com"));
       push @answers, dns_answer(QPTR, T_MX, C_IN, 3600*144, rr_MX(11,"relaybackup.netcetera.dk"));
     }

     $dm->{'answer'}  .= join "", @answers;
     $dm->{'ancount'} += @answers;
   } else {
     $dm->{'rcode'} = NXDOMAIN;
   }
   return 1;
}

sub load_config {
    local($file) = @_;
    my($host,$bg,$a,$b,$c,$d,$ipaddr,$weight,$ip,$groups);

    &write_log("load_config") if $debug;

    %weight=();
    %best_groups=();
    %ip_host=();

    open(CONFIG,$file) || &write_log("Can't open config file: $file: $!");

    while(<CONFIG>) {
       s/^\s+//;
       s/\s+$//;
       next if /^#/ || /^$/;
       ($weight,$host,$ip,$groups) = split(/\s+/,$_,4);
       print "  loading $_\n" if $debug;
       $_ = $ip;
       ($a,$b,$c,$d) =  /(\d+)\.(\d+)\.(\d+)\.(\d+)/;
       $ipaddr = ($a<<24)|($b<<16)|($c<<8)|$d;
       $ip_host{$host} = $ipaddr;
       $weight{$host} = $weight;
       warn "host: $host\n";
       foreach $group (split(/\s+/,$groups)) {
           $best_groups{$group} = [] unless defined $best_groups{$group};
           $bg = $best_groups{$group};
	   push(@$bg,$host);
       }
    }
    warn Data::Dumper->Dump([\%best_groups], [qw(best_groups)]);
    close(CONFIG);
}

############################################################
# standard hooks

sub catch_hup { 
    $need_maint=1; 
    $need_reload=1; 
}

sub do_maint {
    &write_log("do_maint") if $debug;
    if ($need_reload) {
        &write_log("reloading config") if $debug;
        &load_config("$poller_config.lb");
	$need_reload=0;
    }
    $need_maint=0;
}

sub clean_exit {
    &write_log("received signal, exiting...") ;
    &close_log;
    unlink "$0.$opt_p.pid";
    exit(0);
}

sub init_signals {
    $::SIG{'INT'} = 'clean_exit';
    $::SIG{'QUIT'} = 'clean_exit';
    $::SIG{'TERM'} = 'clean_exit';
    $::SIG{'HUP'} = 'catch_hup';
}

&init_signals;
&load_config("$poller_config.lb");

1;


